1.引用计数法---对象A，任何对象引用了对象A, 则A的引用计数器加1，当引用失效时，引用计数器就减1，对象A的引用计数器的值为0，对象A就不能再被引用了。
这种方法存在问题：
  1.循环问题，对象A引用了对象B，对象B又引用了对象A，两个对象的引用计数器都不为0，没有办法回收。
  2.每次引用产生和消除的时候，都伴随一个加法操作和减法操作，对系统性能有影响。
  
2.标记清除法----分为两个阶段标记阶段和清楚阶段。标记阶段，标记所有从根节点开始的可达对象，未被标记的对象就是未被引用的垃圾对象。
                                          在清除阶段，清除所有未被标记的对象。
存在的问题是，回收之后，存在不连续空间。
3.复制算法---将原有的内存分为两个部分，每次只是用一块，在垃圾回收的时候，将正在使用的内存中的存活对象复制到未使用的内存块中，
            清除正在使用的内存中的所有对象

在新生代区域使用了复制算法：垃圾回收时，从新生代存活的对象复制到to，from区域的年轻对象也会被复制到to，那eden和from区域剩余的对象就是垃圾对象

4.标记清除压缩算法----在标记清除算法的基础上，增加了内存碎片整理。标记所有的可达对象，将所有的存活对象压缩到内存的一端，再清理边界外所有的空间。
在老年代，存活对象较多，垃圾对象较少，使用这种算法。

5.分代算法 --- 新生代区和老年代区分开使用不同的回收算法

6.分区算法---按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同小区间。




垃圾回收时的停顿想象：Stop-The-World
停顿的目的是终止所有应用线程的执行，这样，系统中才不会有新的垃圾产生，同时保证了系统状态在某一个瞬间的一致性，也有益于垃圾回收器更好的标记垃圾对象。
